# cfMeDIP-seq differential methylation analysis source code #
#############################################################

# Set directories
scripts <- "../code"
data_dir <- "../data"
out_dir <- "../results"

# Load libraries
library(GenomicRanges)
library(DESeq2)
library(dplyr)
library(ggplot2)
library(RColorBrewer)
library(data.table)
library(purrr)
source(paste0(scripts, "/ggplot_themeJB.R"))

# Load count matrix of cfDNA samples from HNSCC and healthy donors
# previously generated
load(paste0(data_dir, "/cfDNA_CombinedCounts_AllWindows.RData"))

# Subset matrix on PBLdepleted regions previously generated in
# PBL_depleted_windows.R script
load(paste0(out_dir, "/PBLdepleted_IDs.RData"))
cfDNA_CombinedCounts_PBLdepleted <-
  cfDNA_CombinedCounts_AllWindows[rownames(cfDNA_CombinedCounts_AllWindows) %in%
                                    PBLdepleted_IDs,]

rm(cfDNA_CombinedCounts_AllWindows)

# Subset HNSCC patients with detectable ctDNA by CAPP-Seq using data
# previously generated by the CAPPseq_SNV_ident.R script
load(paste0(out_dir, "/cfDNA_PBLfiltered_SNVs_meanMAF.RData"))

HN_CAPPSeq_pos <- cfDNA_PBLfiltered_SNVs_meanMAF[
  cfDNA_PBLfiltered_SNVs_meanMAF$meanMAF > 0,]$upn
HN_CAPPSeq_pos <- substr(HN_CAPPSeq_pos, 3, 6)

cfDNA_CAPPSeqPosCounts_PBLdepleted <-
  cfDNA_CombinedCounts_PBLdepleted[,
                        grepl(paste0(c(HN_CAPPSeq_pos, "Norm"),
                                        collapse = "|"),
                        colnames(cfDNA_CombinedCounts_PBLdepleted))]

# Create colData object for DESeq2 analysis
coldata <-
  data.frame(condition =
               ifelse(grepl("Norm",
                            colnames(cfDNA_CAPPSeqPosCounts_PBLdepleted)),
                      "Norm", "HNC"))
rownames(coldata) <- colnames(cfDNA_CAPPSeqPosCounts_PBLdepleted)

# Create DESeq2 object
dds <- DESeqDataSetFromMatrix(as.matrix(cfDNA_CAPPSeqPosCounts_PBLdepleted),
                              colData = coldata,
                              design = ~ condition)

# Remove rows (300-bp windows) with less than 10 reads across all samples
dds <- dds[rowSums(counts(dds)) >= 10,]

# Perform differential analysis
dds <- DESeq(dds)

res <- results(dds, contrast = c("condition", "HNC", "Norm"))

res_padj <- subset(res, res$padj < 0.1)
res_padj_hyperDMR <- subset(res_padj, res_padj$log2FoldChange > 0)
res_padj_hypoDMR <- subset(res_padj, res_padj$log2FoldChange < 0)

# Create data.frame of results
res_df <- data.frame(x = res$log2FoldChange,
           y = -log10(res$pvalue),
           label = ifelse(is.na(res$padj), "ns",
                          ifelse(res$padj <= 0.1 &
                                   res$log2FoldChange < 0,
                                 "hypo", ifelse(res$padj <= 0.1 &
                                                  res$log2FoldChange > 0,
                                                "hyper", "ns"))))

# Create ggplot
cfDNA_DMRs_plot <- res_df %>%
  ggplot(aes(x = x, y = y, col = label)) +
  geom_point(size = 1.5) +
  annotate("text", x = 4.5, y = 4, label = 'bold("941")',
           size = (5/14) * 9, color = "red", parse = TRUE) +
  annotate("text", x = -4, y = 3.5, label = 'bold("56")',
           size = (5/14) * 9, color = "blue", parse = TRUE) +
  theme_JB() +
  scale_color_manual(name = "DMR:",
                     labels = c("hyper", "hypo", "n.s"),
                     values = c("red", "blue", rgb(0,0,0,1/50))) +
  xlim(-6, 6) +
  ylim(0, 10) +
  labs(x = "log2FC(HNSCC/healthy donor)",
       y = "-log10(pvalue)")

# Determine adjacent non-overlapping windows
## IDtoGRange function to translate genomic coordinates of 300-bp bins
## to a GRange object
IDtoGrange <- function(ID){
  library(GenomicRanges)
  library(BSgenome.Hsapiens.UCSC.hg19)

  Names <- unlist(strsplit(ID, "[.]"))
  Chr <- Names[seq(1,length(Names), by=3)]
  Start <- as.numeric(Names[seq(2,length(Names), by=3)])
  End <- as.numeric(Names[seq(3,length(Names), by=3)])

  GRanges(seqnames=Rle(Chr),
          ranges=IRanges(start=Start, end=End))
}

# Convert hyperDMRs to GRange objects and reduce to adjacent bins
hyperDMR_IDs <- rownames(subset(res, res$log2FoldChange > 0 & res$padj < 0.1))
hyperDMR_gr <- IDtoGrange(hyperDMR_IDs)
hyperDMR_reduced_gr <- GenomicRanges::reduce(hyperDMR_gr)

hyperDMR_reduced_table <-
  table(width(hyperDMR_reduced_gr)) / sum(length(hyperDMR_gr)) * 100
hyperDMR_reduced_df <- data.frame(width = names(hyperDMR_reduced_table),
                                   percent = as.numeric(hyperDMR_reduced_table))
# multiply by number of 300-bp windows
hyperDMR_reduced_df$percent <- hyperDMR_reduced_df$percent * c(1, 2, 3, 4, 5, 6)

hyperDMR_reduced_df$width <- factor(hyperDMR_reduced_df$width,
                                     levels = seq(300,1800,by=300))
# 300 and 1800 denote minimum and maximum widths of windows #

hyperDMR_reducedDMRs_barplot <- hyperDMR_reduced_df %>%
  ggplot(aes(x = width, y = percent)) +
  geom_bar(stat = "identity", position = "dodge",
           col = "lightgrey", fill = "lightgrey", size = 0.13,
           width = 0.75) +
  theme_JB() +
  labs(x = "DMR width (bp)", y = "Percent of all hyperDMRs (%)")

# Assess enrichment of CpG features across hypermethylated DMRs
## Create res_list and function for permutation analysis
res_list <- list(res, res_padj_hyperDMR, res_padj_hypoDMR)
names(res_list) <- c("res", "res_padj_hyperDMR", "res_padj_hypoDMR")

DMR_annotation <- function(res_list, n_replicate = 100){
  # Load annotated windows for subsetting
  ## GenomicRanges object w/ 300bp bins and CpG count
  load(paste0(data_dir, "/CpGgt8_res_gr.RData"))
  ## Dataframe object w/ 300bp bins and CpG feature annotation
  load(paste0(data_dir, "/CpGgt8_Output.RData"))

  # Subset output windows based on hyper/hypoDMRs
  res_ID <- rownames(res_list[['res']])
  hyper_ID <- rownames(res_list[['res_padj_hyperDMR']])
  hypo_ID <- rownames(res_list[['res_padj_hypoDMR']])

  HyperDMR_output <- CpGgt8_Output[CpGgt8_Output$ID %in% hyper_ID,]
  HypoDMR_output <- CpGgt8_Output[CpGgt8_Output$ID %in% hypo_ID,]

  # Create CpG reference
  ## all
  res_gr <- CpGgt8_res_gr[CpGgt8_res_gr$ID %in% res_ID]

  ## hyper/hypometh
  res_hypermeth_gr <- res_gr[res_gr$ID %in% hyper_ID]
  res_hypometh_gr <- res_gr[res_gr$ID %in% hypo_ID]

  # Set up CGI annotation
  res_gr_output <- CpGgt8_Output[CpGgt8_Output$ID %in% res_ID,]
  res_df <- as.data.frame(res_gr)
  res_gr_output <- merge(res_df, res_gr_output, by = "ID")

  # Create function for CpG density calculation
  CGI_enrichment <- function(cpgdensity){
    tmp1 <- c()

    # subsample by CpG density
    for(i in 1:length(cpgdensity)){
      tmp2 <- res_gr_output[res_gr_output$CpG_count == names(cpgdensity)[i],]
      tmp2 <- tmp2[sample(1:nrow(tmp2), cpgdensity[i]),]
      tmp1 <- c(tmp1, tmp2$cgi)
    }
    cpgtable <- (table(tmp1))

    if(is.na(cpgtable['island'])){
      cpgtable2 <- 0
    } else {
      cpgtable2 <- cpgtable['island']
    }

    if(is.na(cpgtable['open sea'])){
      cpgtable2 <- c(cpgtable2, 0)
    } else {
      cpgtable2 <- c(cpgtable2, cpgtable['open sea'])
    }

    if(is.na(cpgtable['shelf'])){
      cpgtable2 <- c(cpgtable2, 0)
    } else {
      cpgtable2 <- c(cpgtable2, cpgtable['shelf'])
    }

    if(is.na(cpgtable['shore'])){
      cpgtable2 <- c(cpgtable2, 0)
    } else {
      cpgtable2 <- c(cpgtable2, cpgtable['shore'])
    }

    names(cpgtable2) <- c("island", "open sea", "shelf", "shore")
    cpgtable <- as.table(cpgtable2)

    return(cpgtable)

  }

  # Perform CGI enrichment test
  ## Hyper DMRs

  HyperDMR_cpgdensity <- table(res_hypermeth_gr$CpG_count)

  set.seed(42)
  CGI_enrichment_test_hyper <- replicate(n_replicate, CGI_enrichment(HyperDMR_cpgdensity))

  CGI_enrichment_zscore_hyper <- matrix(ncol = n_replicate, nrow = 0)

  HyperDMR_obs_CGI <- c()
  HyperDMR_obs_CGI <- c(HyperDMR_obs_CGI, sum(HyperDMR_output$cgi == "island"))
  HyperDMR_obs_CGI <- c(HyperDMR_obs_CGI, sum(HyperDMR_output$cgi == "open sea"))
  HyperDMR_obs_CGI <- c(HyperDMR_obs_CGI, sum(HyperDMR_output$cgi == "shelf"))
  HyperDMR_obs_CGI <- c(HyperDMR_obs_CGI, sum(HyperDMR_output$cgi == "shore"))
  names(HyperDMR_obs_CGI) <- c("island", "open sea", "shelf", "shore")
  HyperDMR_obs_CGI <- as.table(HyperDMR_obs_CGI)

  HyperDMR_obs_CGI_zscore <- c()
  HyperDMR_obs_CGI_pval <- c()

  for(i in 1:nrow(CGI_enrichment_test_hyper)){
    tmp <- CGI_enrichment_test_hyper[i,]
    zscore <- (tmp - mean(tmp)) / sd(tmp)
    CGI_enrichment_zscore_hyper <- rbind(CGI_enrichment_zscore_hyper, zscore)
    HyperDMR_obs_CGI_zscore <- c(HyperDMR_obs_CGI_zscore, (HyperDMR_obs_CGI[i] - mean(tmp)) / sd(tmp))
    if(median(tmp) > HyperDMR_obs_CGI[i]){
      pval <- (1 + sum(tmp > HyperDMR_obs_CGI[i])) / n_replicate
    } else {
      pval <- (1 + sum(tmp < HyperDMR_obs_CGI[i])) / n_replicate
    }
    HyperDMR_obs_CGI_pval <- c(HyperDMR_obs_CGI_pval, pval)
  }
  rownames(CGI_enrichment_zscore_hyper) <- c("island", "open sea", "shelf", "shore")

  ## Hypo DMRs

  HypoDMR_cpgdensity <- table(res_hypometh_gr$CpG_count)

  set.seed(42)
  CGI_enrichment_test_hypo <- replicate(n_replicate, CGI_enrichment(HypoDMR_cpgdensity))

  CGI_enrichment_zscore_hypo <- matrix(ncol = n_replicate, nrow = 0)

  HypoDMR_obs_CGI <- c()
  HypoDMR_obs_CGI <- c(HypoDMR_obs_CGI, sum(HypoDMR_output$cgi == "island"))
  HypoDMR_obs_CGI <- c(HypoDMR_obs_CGI, sum(HypoDMR_output$cgi == "open sea"))
  HypoDMR_obs_CGI <- c(HypoDMR_obs_CGI, sum(HypoDMR_output$cgi == "shelf"))
  HypoDMR_obs_CGI <- c(HypoDMR_obs_CGI, sum(HypoDMR_output$cgi == "shore"))
  names(HypoDMR_obs_CGI) <- c("island", "open sea", "shelf", "shore")
  HypoDMR_obs_CGI <- as.table(HypoDMR_obs_CGI)

  HypoDMR_obs_CGI_zscore <- c()
  HypoDMR_obs_CGI_pval <- c()


  for(i in 1:nrow(CGI_enrichment_test_hypo)){
    tmp <- CGI_enrichment_test_hypo[i,]
    zscore <- (tmp - mean(tmp)) / sd(tmp)
    CGI_enrichment_zscore_hypo <- rbind(CGI_enrichment_zscore_hypo, zscore)
    HypoDMR_obs_CGI_zscore <- c(HypoDMR_obs_CGI_zscore, (HypoDMR_obs_CGI[i] - mean(tmp)) / sd(tmp))


    if(median(tmp) > HypoDMR_obs_CGI[i]){
      pval <- (1 + sum(tmp > HypoDMR_obs_CGI[i])) / n_replicate
    } else {
      pval <- (1 + sum(tmp < HypoDMR_obs_CGI[i])) / n_replicate
    }
    HypoDMR_obs_CGI_pval <- c(HypoDMR_obs_CGI_pval, pval)
  }
  rownames(CGI_enrichment_zscore_hypo) <- c("island", "open sea", "shelf", "shore")

  # Create output list
  CGI_enrichment_list <- list(HyperDMR_output,
                              CGI_enrichment_test_hyper,
                              CGI_enrichment_zscore_hyper,
                              HyperDMR_obs_CGI_zscore,
                              HyperDMR_obs_CGI_pval,
                              HypoDMR_output,
                              CGI_enrichment_test_hypo,
                              CGI_enrichment_zscore_hypo,
                              HypoDMR_obs_CGI_zscore,
                              HypoDMR_obs_CGI_pval)
  names(CGI_enrichment_list) <- c("HyperDMR_output", "CGI_enrichment_test_hyper", "CGI_enrichment_zscore_hyper",
                                  "HyperDMR_obs_CGI_zscore", "HyperDMR_obs_CGI_pval", "HypoDMR_output",
                                  "CGI_enrichment_test_hypo", "CGI_enrichment_zscore_hypo",
                                  "HypoDMR_obs_CGI_zscore", "HypoDMR_obs_CGI_pval")

  return(CGI_enrichment_list)
}

## Perform permutation analysis on DMRs
set.seed(42)
DMR_CpGenrichment <- DMR_annotation(res_list = res_list,
                                    n_replicate = 1000)

## HyperDMRs
CGI_annotation <-
  data.frame(cgi = DMR_CpGenrichment[["HyperDMR_output"]]$cgi)
CGI_annotation$cgi <- factor(CGI_annotation$cgi,
                             levels = c("island", "shore", "shelf", "open sea"))

CGI_enrichment <- data.frame(Var1 = rep(c("island",  "open sea", "shelf", "shore"), 1000),
                             value = c(DMR_CpGenrichment$CGI_enrichment_zscore_hyper))
CGI_enrichment$Var1 <- factor(CGI_enrichment$Var1, levels = c("island", "shore", "shelf", "open sea"))

## Create ggplot
CGI_annotation_plot <- CGI_annotation %>%
  ggplot(aes(x = cgi, fill = cgi)) +
  geom_bar(size = 0.13) +
  scale_fill_manual(values = rev(brewer.pal(4, "Greens"))) +
  theme_JB() +
  theme(axis.ticks.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_text(size = 7),
        axis.title = element_text(size = 7),
        legend.position = "none",
        panel.background = element_blank(),
        plot.margin = unit(c(5,5,-5,5), "mm")) +
  scale_y_continuous(expand = c(0,0)) +
  scale_x_discrete(labels = c("Island", "Shore", "Shelf", "Open sea")) +
  labs(y = "No. of HyperDMRs")

CGI_enrichment_plot <- CGI_enrichment %>%
  ggplot(aes(x = Var1, y = value, fill = Var1)) +
  geom_jitter(position = position_jitter(0.4),
              shape = 16, size = 1.5, col = rgb(0,0,0,1/25)) +
  geom_boxplot(outlier.shape = NA,
               col = "black", fill = NA,
               show.legend = FALSE, lwd = 0.13, fatten = 6) +
  theme_JB() +
  theme(legend.position = "none",
        panel.background = element_blank(),
        axis.text = element_text(size = 7),
        axis.title = element_text(size = 7)) +
  scale_fill_JB() +
  scale_x_discrete(labels = c("Island", "Shore", "Shelf", "Open sea")) +
  ylim(c(-20,20)) +
  labs(y = "z-score") +
  theme(axis.title.x = element_blank(),
        plot.margin = unit(c(5,5,15,5), "mm")) +
  annotation_custom(pointsGrob(gp = gpar(col = NA,
                                         fill = "red",
                                         cex = 0.5),
                               pch = 23),
                    xmin = 1, xmax=1,
                    ymin = DMR_CpGenrichment[["HyperDMR_obs_CGI_zscore"]][1],
                    ymax = DMR_CpGenrichment[["HyperDMR_obs_CGI_zscore"]][1]) +
  annotation_custom(pointsGrob(gp = gpar(fill = "blue", col = NA,
                                         cex = 0.5),
                               pch = 23),
                    xmin = 2, xmax=2,
                    ymin = DMR_CpGenrichment[["HyperDMR_obs_CGI_zscore"]][4],
                    ymax = DMR_CpGenrichment[["HyperDMR_obs_CGI_zscore"]][4]) +
  annotation_custom(pointsGrob(gp = gpar(fill = "lightgrey", col = NA,
                                         cex = 0.5),
                               pch = 23),
                    xmin = 3, xmax=3,
                    ymin = DMR_CpGenrichment[["HyperDMR_obs_CGI_zscore"]][3],
                    ymax = DMR_CpGenrichment[["HyperDMR_obs_CGI_zscore"]][3]) +
  annotation_custom(pointsGrob(gp = gpar(fill = "blue", col = NA,
                                         cex = 0.5),
                               pch = 23),
                    xmin = 4, xmax=4,
                    ymin = DMR_CpGenrichment[["HyperDMR_obs_CGI_zscore"]][2],
                    ymax = DMR_CpGenrichment[["HyperDMR_obs_CGI_zscore"]][2]) +
  annotation_custom(legendGrob(labels = c("enriched", "depleted", "n.s"),
                               nrow = 1, ncol = 3,
                               pch = 23, gp = gpar(fill = c("red","blue",
                                                            "lightgrey"),
                                                   col = NA,
                                                   cex = 0.5)),
                    xmin = 0.5, xmax = 4.5, ymin = -40, ymax = -40) +
  coord_cartesian(clip = "off")

CGI_DMRandEnrichment_plot <- egg::ggarrange(CGI_annotation_plot,
                                            CGI_enrichment_plot,
                                            nrow = 2, ncol = 1,
                                            heights = c(0.5, 1))

## HypoDMRs
CGI_hypo_annotation <-
  data.frame(cgi = DMR_CpGenrichment[["HypoDMR_output"]]$cgi)
CGI_hypo_annotation$cgi <- factor(CGI_hypo_annotation$cgi,
                             levels = c("island", "shore", "shelf", "open sea"))

CGI_hypo_enrichment <- melt(DMR_CpGenrichment[["CGI_enrichment_zscore_hyper"]])
CGI_hypo_enrichment$Var1 <- factor(CGI_hypo_enrichment$Var1, levels = c("island", "shore",
                                                              "shelf", "open sea"))

## Create ggplot
CGI_hypo_annotation_plot <- CGI_hypo_annotation %>%
  ggplot(aes(x = cgi, fill = cgi)) +
  geom_bar(size = 0.13) +
  scale_fill_manual(values = rev(brewer.pal(4, "Greens"))) +
  theme_JB() +
  theme(axis.ticks.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_text(size = 7),
        axis.title = element_text(size = 7),
        legend.position = "none",
        panel.background = element_blank(),
        plot.margin = unit(c(5,5,-5,5), "mm")) +
  scale_y_continuous(expand = c(0,0)) +
  scale_x_discrete(labels = c("Island", "Shore", "Shelf", "Open sea")) +
  labs(y = "No. of HypoDMRs")

CGI_hypo_enrichment_plot <- CGI_hypo_enrichment %>%
  ggplot(aes(x = Var1, y = value, fill = Var1)) +
  geom_jitter(position = position_jitter(0.4),
              shape = 16, size = 1.5, col = rgb(0,0,0,1/25)) +
  geom_boxplot(outlier.shape = NA,
               col = "black", fill = NA,
               show.legend = FALSE, lwd = 0.13, fatten = 6) +
  theme_JB() +
  theme(legend.position = "none",
        panel.background = element_blank(),
        axis.text = element_text(size = 7),
        axis.title = element_text(size = 7)) +
  scale_fill_JB() +
  scale_x_discrete(labels = c("Island", "Shore", "Shelf", "Open sea")) +
  ylim(c(-10,10)) +
  labs(y = "z-score") +
  theme(axis.title.x = element_blank(),
        plot.margin = unit(c(5,5,15,5), "mm")) +
  annotation_custom(pointsGrob(gp = gpar(col = NA,
                                         fill = "blue",
                                         cex = 0.5),
                               pch = 23),
                    xmin = 1, xmax=1,
                    ymin = DMR_CpGenrichment[["HypoDMR_obs_CGI_zscore"]][1],
                    ymax = DMR_CpGenrichment[["HypoDMR_obs_CGI_zscore"]][1]) +
  annotation_custom(pointsGrob(gp = gpar(fill = "lightgrey", col = NA,
                                         cex = 0.5),
                               pch = 23),
                    xmin = 2, xmax=2,
                    ymin = DMR_CpGenrichment[["HypoDMR_obs_CGI_zscore"]][4],
                    ymax = DMR_CpGenrichment[["HypoDMR_obs_CGI_zscore"]][4]) +
  annotation_custom(pointsGrob(gp = gpar(fill = "lightgrey", col = NA,
                                         cex = 0.5),
                               pch = 23),
                    xmin = 3, xmax=3,
                    ymin = DMR_CpGenrichment[["HypoDMR_obs_CGI_zscore"]][3],
                    ymax = DMR_CpGenrichment[["HypoDMR_obs_CGI_zscore"]][3]) +
  annotation_custom(pointsGrob(gp = gpar(fill = "red", col = NA,
                                         cex = 0.5),
                               pch = 23),
                    xmin = 4, xmax=4,
                    ymin = DMR_CpGenrichment[["HypoDMR_obs_CGI_zscore"]][2],
                    ymax = DMR_CpGenrichment[["HypoDMR_obs_CGI_zscore"]][2]) +
  annotation_custom(legendGrob(labels = c("enriched", "depleted", "n.s"),
                               nrow = 1, ncol = 3,
                               pch = 23, gp = gpar(fill = c("red","blue",
                                                            "lightgrey"),
                                                   col = NA,
                                                   cex = 0.5)),
                    xmin = 0.5, xmax = 4.5, ymin = -15, ymax = -15) +
  coord_cartesian(clip = "off")

CGI_DMRandhypo_enrichment_plot <- egg::ggarrange(CGI_hypo_annotation_plot,
                                            CGI_hypo_enrichment_plot,
                                            nrow = 2, ncol = 1,
                                            heights = c(0.5, 1))

# Perform TCGA enrichment analysis
## Create function for TCGA analysis
TCGA_hyperperm <- function(res_list, n_replicate=10){

  set.seed(42)

  # Identify tumour-specific hyperDMCs
  load(paste0(data_dir, "/Combined450K_df.RData"))

  # Load hyperDMCs from h4hcluster analysis
  ## Select site-specific IDs
  tumours <- c("BRCA","COAD","LUAD","OSCC","PAAD","PRAD")
  filedir <- paste0(out_dir, "/tcgaHyperDmr")
  sitespecific_vs_all_HyperDMRs <- list()
  sitespecific_vs_all_probeIDS <- list()
  for(i in 1:length(tumours)){
    sitefiles <-
      list.files(filedir,
                 pattern=paste0(tumours[i],"_vs"),
                 full.names = T)[!grepl("LUSC",
                                        list.files(filedir,
                                                   pattern=paste0(tumours[i],
                                                                  "_vs"),
                                                   full.names = T))]
    probeID_list <- list()
    windows_list <- list()
    for(n in 1:length(sitefiles)){
      label <-
        strsplit(strsplit(list.files(filedir,
                                     pattern=paste0(tumours[i],"_vs"),
                                     full.names = T)[n], split="/")[[1]][8],
                 split="[.]")[[1]][1]
      tmp <- read.table(sitefiles[n], sep="\t",
                        col.names = c("chr","start","end","probeID"))
      probeIDs <- as.character(tmp$probeID)
      windows <- paste(tmp$chr, tmp$start, tmp$end, sep=".")
      probeID_list[[n]] <- probeIDs
      names(probeID_list)[n] <- label
      windows_list[[n]] <- windows
      names(windows_list)[n] <- label
    }
    sitespecific_vs_all_probeIDS[[i]] <-
      names(table(unlist(probeID_list))[table(unlist(probeID_list)) == 6])
    names(sitespecific_vs_all_probeIDS)[i] <- tumours[i]
    sitespecific_vs_all_HyperDMRs[[i]] <-
      names(table(unlist(windows_list))[table(unlist(windows_list)) == 6])
    names(sitespecific_vs_all_HyperDMRs)[i] <- tumours[i]
  }

  # Permutation of site-specific DMRs
  load(paste0(out_dir, "/sitespecific_vs_all_probeIDs.RData"))
  Phenotype <- c()
  for(label in colnames(Combined450K_df)){
    if(grepl("HNSC", label)) Phenotype <- c(Phenotype, "OSCC")
    if(grepl("BRCA", label)) Phenotype <- c(Phenotype, "BRCA")
    if(grepl("COAD", label)) Phenotype <- c(Phenotype, "COAD")
    if(grepl("LUSC", label)) Phenotype <- c(Phenotype, "LUSC")
    if(grepl("LUAD", label)) Phenotype <- c(Phenotype, "LUAD")
    if(grepl("PRAD", label)) Phenotype <- c(Phenotype, "PRAD")
    if(grepl("PAAD", label)) Phenotype <- c(Phenotype, "PAAD")
    if(grepl("PBL", label)) Phenotype <- c(Phenotype, "PBL")
  }

  # Load files
  load(paste0(data_dir, "/probeID_to_300bp_wCpG.RData"))

  ref_IDs <- rownames(res_list[['res']])
  ref_hyperDMR_IDs <- rownames(res_list[['res_padj_hyperDMR']])

  ID300bp_wCpG <- unique(probeID_to_300bp_wCpG[,2:3])
  All_450K_Windows_ID <- as.character(unique(probeID_to_300bp_wCpG$ID[probeID_to_300bp_wCpG$ID %in% ref_IDs]))

  # Convert probeIDs of interest to 300bp windows
  sitespecific_vs_all_probeIDS_to_300bp <- list()
  for(i in 1:length(sitespecific_vs_all_probeIDS)){
    ID <- as.character(unique(probeID_to_300bp_wCpG[probeID_to_300bp_wCpG$probeID %in% sitespecific_vs_all_probeIDS[[i]],]$ID))
    sitespecific_vs_all_probeIDS_to_300bp[[i]] <- ID
    names(sitespecific_vs_all_probeIDS_to_300bp)[i] <- names(sitespecific_vs_all_probeIDS)[i]
  }

  # Create dependants...
  ## Functions
  cpgperm <- function(CpG_list, reference, allIDs_wCpG){
    output <- c()
    cpgs <- table(CpG_list)
    for(i in 1:length(cpgs)){
      tmp <- allIDs_wCpG[allIDs_wCpG$CpG == as.numeric(names(cpgs[i])),]
      tmp_index <- sample(1:nrow(tmp), as.numeric(cpgs[i]))
      overlap <- sum(tmp[tmp_index,]$ID %in% reference)
      output <- c(output, overlap)
    }
    return(sum(output))
  }

  ## Generate CpG_list of HyperDMRs
  CpG_list <- ID300bp_wCpG$CpG[ID300bp_wCpG$ID %in% ref_hyperDMR_IDs]
  ## Generate allIDs_wCpG
  allIDs_wCpG <- unique(probeID_to_300bp_wCpG[probeID_to_300bp_wCpG$ID %in% All_450K_Windows_ID,c(2,3)])

  # Permutation analysis
  ## Calculate overlap of HyperDMRs to TCGA Hyper DMC probeIDs
  DMR_overlap <- c()
  for(i in 1:length(sitespecific_vs_all_probeIDS_to_300bp)){
    DMR_overlap <- c(DMR_overlap, sum(ref_hyperDMR_IDs %in% sitespecific_vs_all_probeIDS_to_300bp[[i]]))
    names(DMR_overlap)[i] <- names(sitespecific_vs_all_probeIDS_to_300bp)[i]
  }
  ## Perform permutation for each condition
  random_overlap_list <- list()
  for(i in 1:length(sitespecific_vs_all_probeIDS_to_300bp)){
    cat("Performing permutation analysis on", names(sitespecific_vs_all_probeIDS_to_300bp)[i],"...\n")
    random_overlap <- replicate(n_replicate, cpgperm(CpG_list=CpG_list,
                                                     reference=sitespecific_vs_all_probeIDS_to_300bp[[i]],
                                                     allIDs_wCpG=allIDs_wCpG))
    random_overlap_list[[i]] <- random_overlap
    names(random_overlap_list)[i] <- names(sitespecific_vs_all_probeIDS_to_300bp)[i]
  }
  ## Calculate pvalue
  DMR_observed_pval <- c()
  for(i in 1:length(DMR_overlap)){
    ### Calculate pval
    observed_val <- DMR_overlap[i]
    random_vals <- random_overlap_list[[i]]
    if(observed_val < median(random_vals)){
      b <- sum(random_vals < observed_val)
      pval <- (b+1) / n_replicate
    } else {
      b <- sum(random_vals > observed_val)
      pval <- (b+1) / n_replicate
    }
    DMR_observed_pval <- c(DMR_observed_pval, pval)
    names(DMR_observed_pval)[i] <- names(DMR_overlap)[i]
  }

  permutation_results <- list(DMR_overlap, random_overlap_list, DMR_observed_pval)
  names(permutation_results)[1] <- "Observed_overlap"
  names(permutation_results)[2] <- "Random_overlap"
  names(permutation_results)[3] <- "p_val"

  # calculate p-val
  ## z-score function
  zscore_calc <- function(x){
    (x - mean(x)) / sd (x)
  }

  # Normalize overlaps by z-score
  zscore_convert <- function(Permutation_results){
    # Convert random overlap
    random_overlap_zscore_list <- list()
    for(i in 1:length(Permutation_results[[2]])){
      random_overlap_zscore_list[[i]] <- zscore_calc(Permutation_results[[2]][[i]])
      names(random_overlap_zscore_list)[i] <- names(Permutation_results[[2]])[i]
    }

    # Convert observed overlap
    observed_overlap_zscore <- c()
    for(i in 1:length(Permutation_results[[1]])){
      value <- Permutation_results[[1]][[i]]
      value_zscore <- (value - mean(Permutation_results[[2]][[i]])) / sd(Permutation_results[[2]][[i]])
      observed_overlap_zscore <- c(observed_overlap_zscore, value_zscore)
      names(observed_overlap_zscore)[i] <- names(Permutation_results[[1]])[i]
    }
    zscore_output <- list(observed_overlap_zscore, random_overlap_zscore_list)
    names(zscore_output) <- c("observed_overlap", "random_overlap")

    return(zscore_output)
  }

  zscore_values <- zscore_convert(Permutation_results = permutation_results)

  permutation_results[['zscore_values']] <- zscore_values

  return(permutation_results)
}

hyperDMR_TCGAobj <- TCGA_hyperperm(res_list = res_list,
                                   n_replicate = 10000)

# Create ggplot of TCGA enrichment results
hyperDMR_TCGAobj_zscores <-
  hyperDMR_TCGAobj$zscore_values$random_overlap[c(1,2,5,7)]
names(hyperDMR_TCGAobj_zscores) <- c("BRCA", "COAD", "HNSC", "PRAD")
hyperDMR_TCGAobj_zscores <- melt(as.data.table(hyperDMR_TCGAobj_zscores))

TCGA_hyper_annotation <- data.frame(
  tcga = names(hyperDMR_TCGAobj$Observed_overlap),
  count = hyperDMR_TCGAobj$Observed_overlap)

TCGA_hyper_annotation <- TCGA_hyper_annotation[c(1,2,5,7),]



TCGA_hyper_annotation_plot <- TCGA_hyper_annotation %>%
  ggplot(aes(x = tcga, y = count, fill = tcga)) +
  geom_bar(size = 0.13, stat = "identity") +
  scale_fill_manual(values = rev(brewer.pal(4, "Greens"))) +
  theme_JB() +
  theme(axis.ticks.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_text(size = 7),
        axis.title = element_text(size = 7),
        legend.position = "none",
        panel.background = element_blank(),
        plot.margin = unit(c(5,5,-5,5), "mm")) +
  scale_y_continuous(expand = c(0,0)) +
  scale_x_discrete(labels = c("BRCA", "COAD", "HNSC", "PRAD")) +
  labs(y = "No. of overlapping\nhyper-DMRs")

hyperDMR_TCGA_enrichment_plot <- hyperDMR_TCGAobj_zscores %>%
  ggplot(aes(x = variable, y = value)) +
  geom_jitter(position = position_jitter(0.4),
              shape = 16, size = 0.2, col = rgb(0,0,0,1/500)) +
  geom_boxplot(outlier.shape = NA,
               show.legend = FALSE, col = "black", fill = NA,
               lwd = 0.13, fatten = 6) +
  theme_JB() +
  scale_fill_JB() +
  ylim(c(-10,10)) +
  labs(y = "z-score") +
  theme(axis.title.x = element_blank(),
        plot.margin = unit(c(5,5,15,5), "mm"),
        axis.text = element_text(size = 7),
        axis.title = element_text(size = 7),
        panel.background = element_blank()) +
  annotation_custom(pointsGrob(gp = gpar(col = "NA",
                                         fill = "blue",
                                         cex = 0.5),
                               pch = 23),
                    xmin = 1, xmax=1,
                    ymin = hyperDMR_TCGAobj$zscore_values$observed_overlap[1],
                    ymax = hyperDMR_TCGAobj$zscore_values$observed_overlap[1]) +
  annotation_custom(pointsGrob(gp = gpar(col = "NA",
                                         fill = "blue",
                                         cex = 0.5),
                               pch = 23),
                    xmin = 2, xmax=2,
                    ymin = hyperDMR_TCGAobj$zscore_values$observed_overlap[2],
                    ymax = hyperDMR_TCGAobj$zscore_values$observed_overlap[2]) +
  annotation_custom(pointsGrob(gp = gpar(col = NA,
                                         fill = "red",
                                         cex = 0.5),
                               pch = 23),
                    xmin = 3, xmax=3,
                    ymin = hyperDMR_TCGAobj$zscore_values$observed_overlap[5],
                    ymax = hyperDMR_TCGAobj$zscore_values$observed_overlap[5]) +
  annotation_custom(pointsGrob(gp = gpar(col = NA,
                                         fill = "blue",
                                         cex = 0.5),
                               pch = 23),
                    xmin = 4, xmax=4,
                    ymin = hyperDMR_TCGAobj$zscore_values$observed_overlap[7],
                    ymax = hyperDMR_TCGAobj$zscore_values$observed_overlap[7]) +
  annotation_custom(legendGrob(labels = c("enriched", "depleted"),
                               nrow = 1, ncol = 3,
                               pch = 23, gp = gpar(fill = c("red","blue"),
                                                   col = NA,
                                                   cex = 0.5)),
                    xmin = 0.5, xmax = 4.5, ymin = -17, ymax = -17) +
  coord_cartesian(clip = "off")


TCGA_DMRandhyper_enrichment_plot <- egg::ggarrange(TCGA_hyper_annotation_plot,
                                                   hyperDMR_TCGA_enrichment_plot,
                                                 nrow = 2, ncol = 1,
                                                 heights = c(0.5, 1))



# Repeat with hypomethylated regions
res_hypo_list <- res_list
## for function redundancy...
res_hypo_list$res_padj_hyperDMR <- res_hypo_list$res_padj_hypoDMR

hypoDMR_TCGAobj <- TCGA_hyperperm(res_list = res_hypo_list,
                                   n_replicate = 10000)

# Create ggplot of TCGA enrichment results
hypoDMR_TCGAobj_zscores <-
  hypoDMR_TCGAobj$zscore_values$random_overlap[c(1,2,5,7)]
names(hypoDMR_TCGAobj_zscores) <- c("BRCA", "COAD", "HNSC", "PRAD")
hypoDMR_TCGAobj_zscores <- melt(hypoDMR_TCGAobj_zscores)

hypoDMR_TCGA_enrichment_plot <- hypoDMR_TCGAobj_zscores %>%
  ggplot(aes(x = L1, y = value)) +
  geom_jitter(position = position_jitter(0.4),
              shape = 16, size = 1.5, col = rgb(0,0,0,1/200)) +
  geom_boxplot(outlier.shape = NA,
               show.legend = FALSE, col = "black", fill = NA,
               lwd = 0.13, fatten = 6) +
  theme_JB() +
  scale_fill_JB() +
  ylim(c(-10,10)) +
  labs(y = "z-score") +
  theme(axis.title.x = element_blank(),
        plot.margin = unit(c(5,5,15,5), "mm"),
        axis.text = element_text(size = 7),
        axis.title = element_text(size = 7)) +
  annotation_custom(pointsGrob(gp = gpar(col = "NA",
                                         fill = "blue",
                                         cex = 0.8),
                               pch = 23),
                    xmin = 1, xmax=1,
                    ymin = hypoDMR_TCGAobj$zscore_values$observed_overlap[1],
                    ymax = hypoDMR_TCGAobj$zscore_values$observed_overlap[1]) +
  annotation_custom(pointsGrob(gp = gpar(col = "NA",
                                         fill = "blue",
                                         cex = 0.8),
                               pch = 23),
                    xmin = 2, xmax=2,
                    ymin = hypoDMR_TCGAobj$zscore_values$observed_overlap[2],
                    ymax = hypoDMR_TCGAobj$zscore_values$observed_overlap[2]) +
  annotation_custom(pointsGrob(gp = gpar(col = NA,
                                         fill = "red",
                                         cex = 0.8),
                               pch = 23),
                    xmin = 3, xmax=3,
                    ymin = hypoDMR_TCGAobj$zscore_values$observed_overlap[5],
                    ymax = hypoDMR_TCGAobj$zscore_values$observed_overlap[5]) +
  annotation_custom(pointsGrob(gp = gpar(col = NA,
                                         fill = "blue",
                                         cex = 0.8),
                               pch = 23),
                    xmin = 4, xmax=4,
                    ymin = hypoDMR_TCGAobj$zscore_values$observed_overlap[7],
                    ymax = hypoDMR_TCGAobj$zscore_values$observed_overlap[7]) +
  annotation_custom(legendGrob(labels = c("enriched", "depleted"),
                               nrow = 1, ncol = 3,
                               pch = 23, gp = gpar(fill = c("red","blue"),
                                                   col = NA,
                                                   cex = 0.8)),
                    xmin = 0.5, xmax = 4.5, ymin = -14, ymax = -14) +
  coord_cartesian(clip = "off")

# Save DESeq2 result list for subsequent analysis
save(res_list, res_hypo_list,
     file = paste0(out_dir, "/DESeq2_cfDNA_DMRs.RData"))

